//! A module that is responsible for migration of storage for Collator Selection.

use super::*;
use frame_support::traits::OnRuntimeUpgrade;
use log;

/// Version 1 Migration
/// This migration ensures that any existing `Invulnerables` storage lists are sorted.
pub mod v1 {
    use super::*;
    use frame_support::pallet_prelude::*;
    #[cfg(feature = "try-runtime")]
    use sp_std::prelude::*;

    pub struct MigrateToV1<T>(sp_std::marker::PhantomData<T>);
    impl<T: Config> OnRuntimeUpgrade for MigrateToV1<T> {
        fn on_runtime_upgrade() -> Weight {
            let on_chain_version = Pallet::<T>::on_chain_storage_version();
            if on_chain_version == 0 {
                let invulnerables_len = Invulnerables::<T>::get().to_vec().len();
                <Invulnerables<T>>::mutate(|invulnerables| {
                    invulnerables.sort();
                });

                StorageVersion::new(1).put::<Pallet<T>>();
                log::info!(
                    target: LOG_TARGET,
                    "Sorted {} Invulnerables, upgraded storage to version 1",
                    invulnerables_len,
                );
                // Similar complexity to `set_invulnerables` (put storage value)
                // Plus 1 read for length, 1 read for `on_chain_version`, 1 write to put version
                T::WeightInfo::set_invulnerables(invulnerables_len as u32)
                    .saturating_add(T::DbWeight::get().reads_writes(2, 1))
            } else {
                log::info!(
                    target: LOG_TARGET,
                    "Migration did not execute. This probably should be removed"
                );
                T::DbWeight::get().reads(1)
            }
        }

        #[cfg(feature = "try-runtime")]
        fn pre_upgrade() -> Result<Vec<u8>, sp_runtime::DispatchError> {
            let number_of_invulnerables = Invulnerables::<T>::get().to_vec().len();
            Ok((number_of_invulnerables as u32).encode())
        }

        #[cfg(feature = "try-runtime")]
        fn post_upgrade(number_of_invulnerables: Vec<u8>) -> Result<(), sp_runtime::DispatchError> {
            let stored_invulnerables = Invulnerables::<T>::get().to_vec();
            let mut sorted_invulnerables = stored_invulnerables.clone();
            sorted_invulnerables.sort();
            assert_eq!(
                stored_invulnerables, sorted_invulnerables,
                "after migration, the stored invulnerables should be sorted"
            );

            let number_of_invulnerables: u32 = Decode::decode(
                &mut number_of_invulnerables.as_slice(),
            )
            .expect("the state parameter should be something that was generated by pre_upgrade");
            let stored_invulnerables_len = stored_invulnerables.len() as u32;
            assert_eq!(
                number_of_invulnerables, stored_invulnerables_len,
                "after migration, there should be the same number of invulnerables"
            );

            let on_chain_version = Pallet::<T>::on_chain_storage_version();
            frame_support::ensure!(on_chain_version >= 1, "must_upgrade");

            Ok(())
        }
    }
}
